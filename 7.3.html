<DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Implementation issues</title>

</head>
<body>
    <main>
        <p> Software engineering includes all of the activities involved in software development
 from the initial requirements of the system through to maintenance and manage
ment of the deployed system. A critical stage of this process is, of course, system
 implementation, where you create an executable version of the software.
 Implementation may involve developing programs in high- or low-level programming
 languages or tailoring and adapting generic, off-the-shelf systems to meet the specific
 requirements of an organization.</p>
 <p>I assume that most readers of this book will understand programming principles
 and will have some programming experience. As this chapter is intended to offer a
 language-independent approach, I haven’t focused on issues of good programming
 practice as this has to use language-specific examples. Instead, I introduce some
 aspects of implementation that are particularly important to software engineering
 that are often not covered in programming texts. These are:</p>

 <p> 1. Reuse Most modern software is constructed by reusing existing components or
 systems. When you are developing software, you should make as much use as
 possible of existing code.</p>

 <p>2. Configuration management During the development process, many different
 versions of each software component are created. If you don’t keep track of
 these versions in a configuration management system, you are liable to include
 the wrong versions of these components in your system.</p>

 <p> 3. Host-target development Production software does not usually execute on the
 same computer as the software development environment. Rather, you develop
 it on one computer (the host system) and execute it on a separate computer (the
 target system). The host and target systems are sometimes of the same type but,
 often they are completely different.</p>

 <h1> 7.3.1 Reuse</h1>

 <p> From the 1960s to the 1990s, most new software was developed from scratch, by
 writing all code in a high-level programming language. The only significant reuse or  software was the reuse of functions and objects in programming language libraries.
 However, costs and schedule pressure meant that this approach became increasingly
 unviable, especially for commercial and Internet-based systems. Consequently, an
 approach to development based around the reuse of existing software emerged and is
 now generally used for business systems, scientific software, and, increasingly, in
 embedded systems engineering.
 Software reuse is possible at a number of different levels:
</p>


<p> 1. The abstraction level At this level, you don’t reuse software directly but rather
 use knowledge of successful abstractions in the design of your software. Design
 patterns and architectural patterns (covered in Chapter 6) are ways of represent
ing abstract knowledge for reuse.</p>

<P>2. The object level At this level, you directly reuse objects from a library rather
 than writing the code yourself. To implement this type of reuse, you have to find
 appropriate libraries and discover if the objects and methods offer the function
ality that you need. For example, if you need to process mail messages in a Java
 program, you may use objects and methods from a JavaMail library.</P>

 <p>2. The object level At this level, you directly reuse objects from a library rather
 than writing the code yourself. To implement this type of reuse, you have to find
 appropriate libraries and discover if the objects and methods offer the function
ality that you need. For example, if you need to process mail messages in a Java
 program, you may use objects and methods from a JavaMail library.</p>

 <p> 4. The system level At this level, you reuse entire application systems. This usually
 involves some kind of configuration of these systems. This may be done by
 adding and modifying code (if you are reusing a software product line) or by
 using the system’s own configuration interface. Most commercial systems are
 now built in this way where generic COTS (commercial off-the-shelf) systems
 are adapted and reused. Sometimes this approach may involve reusing several
 different systems and integrating these to create a new system.</p>

 <p>By reusing existing software, you can develop new systems more quickly, with
 fewer development risks and also lower costs. As the reused software has been tested
 in other applications, it should be more reliable than new software. However, there
 are costs associated with reuse:</p>

 <p> 1. The costs of the time spent in looking for software to reuse and assessing
 whether or not it meets your needs. You may have to test the software to make
 sure that it will work in your environment, especially if this is different from its
 development environment.</p>

 <p> 2. Where applicable, the costs of buying the reusable software. For large off-the
shelf systems, these costs can be very high.</p>

<p> 3. The costs of adapting and configuring the reusable software components or sys
tems to reflect the requirements of the system that you are developing.</p>

<p> 4. The costs of integrating reusable software elements with each other (if you are
 using software from different sources) and with the new code that you have
 developed. Integrating reusable software from different providers can be diffi
cult and expensive because the providers may make conflicting assumptions
 about how their respective software will be reused.</p>

 <p>How to reuse existing knowledge and software should be the first thing you should
 think about when starting a software development project. You should consider the
 possibilities of reuse before designing the software in detail, as you may wish to adapt
 your design to reuse existing software assets. As I discussed in Chapter 2, in a reuse
oriented development process, you search for reusable elements then modify your
 requirements and design to make best use of these.
 For a large number of application systems, software engineering really means
 software reuse. I therefore devote several chapters in the software technologies sec
tion of the book to this topic (Chapters 16, 17, and 19).</p>

<h1> 7.3.2 Configuration management</h1>

<p> In software development, change happens all the time, so change management is
 absolutely essential. When a team of people are developing software, you have to
 make sure that team members don’t interfere with each others’ work. That is, if two
 people are working on a component, their changes have to be coordinated. Otherwise,
 one programmer may make changes and overwrite the other’s work. You also have to
 ensure that everyone can access the most up-to-date versions of software components,
 otherwise developers may redo work that has already been done. When something
 goes wrong with a new version of a system, you have to be able to go back to a work
ing version of the system or component.</p>

<p>Configuration management is the name given to the general process of managing
 a changing software system. The aim of configuration management is to support the
 system integration process so that all developers can access the project code and doc
uments in a controlled way, find out what changes have been made, and compile and
 link components to create a system. There are, therefore, three fundamental configu
ration management activities:</p>

<p> 1. Version management, where support is provided to keep track of the different
 versions of software components. Version management systems include facili
ties to coordinate development by several programmers. They stop one devel
oper overwriting code that has been submitted to the system by someone else.</p>

<p> 2. System integration, where support is provided to help developers define what
 versions of components are used to create each version of a system. This
 description is then used to build a system automatically by compiling and link
ing the required components.</p>

<p>3. Problem tracking, where support is provided to allow users to report bugs and
 other problems, and to allow all developers to see who is working on these prob
lems and when they are fixed.</p>

<p> Software configuration management tools support each of the above activities.
 These tools may be designed to work together in a comprehensive change management
 system, such as ClearCase (Bellagio and Milligan, 2005). In integrated configuration
 management systems, version management, system integration, and problem-tracking
 tools are designed together. They share a user interface style and are integrated through
 a common code repository.</p>

 <p>Alternatively, separate tools, installed in an integrated development environment,
 may be used. Version management may be supported using a version management
 system such as Subversion (Pilato et al., 2008), which can support multi-site, multi
team development. System integration support may be built into the language or rely
 on a separate toolset such as the GNU build system. This includes what is perhaps
 the best-known integration tool, Unix make. Bug tracking or issue tracking systems,
 such as Bugzilla, are used to report bugs and other issues and to keep track of
 whether or not these have been fixed.</p>

 <p>Because of its importance in professional software engineering, I discuss change
 and configuration management in more detail in Chapter 25.</p>

 <h1> 7.3.3 Host-target development</h1>

 <p> Most software development is based on a host-target model. Software is developed on
 one computer (the host), but runs on a separate machine (the target). More generally,
 we can talk about a development platform and an execution platform. A platform is
 more than just hardware. It includes the installed operating system plus other support
ing software such as a database management system or, for development platforms,
 an interactive development environment.</p>

 <p> Sometimes, the development and execution platforms are the same, making it possi
ble to develop the software and test it on the same machine. More commonly, however,
 they are different so that you need to either move your developed software to the execu
tion platform for testing or run a simulator on your development machine.</p>

<p>Simulators are often used when developing embedded systems. You simulate hard
ware devices, such as sensors, and the events in the environment in which the system
 will be deployed. Simulators speed up the development process for embedded systems
 as each developer can have their own execution platform with no need to download the
 software to the target hardware. However, simulators are expensive to develop and so
 are only usually available for the most popular hardware architectures.</p>

 <p> If the target system has installed middleware or other software that you need to
 use, then you need to be able to test the system using that software. It may be imprac
tical to install that software on your development machine, even if it is the same as
 the target platform, because of license restrictions. In those circumstances, you need
 to transfer your developed code to the execution platform to test the system.
</p>

<section>
    <img src="Table 1.png" alt="">
</section>

<p>A software development platform should provide a range of tools to support soft
ware engineering processes. These may include:</p>

<p> 1. An integrated compiler and syntax-directed editing system that allows you to
 create, edit, and compile code.</p>

 <p>2. A language debugging system.</p>

 <p> 3. Graphical editing tools, such as tools to edit UML models.</p>

 <p> 4. Testing tools, such as JUnit (Massol, 2003) that can automatically run a set of
 tests on a new version of a program.</p>

 <p> 5. Project support tools that help you organize the code for different development
 projects.</p>

 <p> As well as these standard tools, your development system may include more special
ized tools such as static analyzers (discussed in Chapter 15). Normally, development
 environments for teams also include a shared server that runs a change and con
figuration management system and, perhaps, a system to support requirements
 management.</p>

 <p>Software development tools are often grouped to create an integrated develop
ment environment (IDE). An IDE is a set of software tools that supports different
 aspects of software development, within some common framework and user inter
face. Generally, IDEs are created to support development in a specific programming
 language such as Java. The language IDE may be developed specially, or may be an
 instantiation of a general-purpose IDE, with specific language-support tools.</p>

 <p>A general-purpose IDE is a framework for hosting software tools that provides data
 management facilities for the software being developed, and integration mechanisms,
 that allow tools to work together. The best-known general-purpose IDE is the Eclipse
 environment (Carlson, 2005). This environment is based on a plug-in architecture so
 that it can be specialized for different languages and application domains (Clayberg and
 Rubel, 2006). Therefore, you can install Eclipse and tailor it for your specific needs by
 adding plug-ins. For example, you may add a set of plug-ins to support networked sys
tems development in Java or embedded systems engineering using C.</p>

<p>As part of the development process, you need to make decisions about how the
 developed software will be deployed on the target platform. This is straightforward for embedded systems, where the target is usually a single computer. However, for
 distributed systems, you need to decide on the specific platforms where the compo
nents will be deployed. Issues that you have to consider in making this decision are: </p>

<p> 1. The hardware and software requirements of a component If a component is
 designed for a specific hardware architecture, or relies on some other software
 system, it must obviously be deployed on a platform that provides the required
 hardware and software support.</p>

 <p> 2. The availability requirements of the system High-availability systems may
 require components to be deployed on more than one platform. This means that,
 in the event of platform failure, an alternative implementation of the component
 is availablea.</p>

 <p>3. Component communications If there is a high level of communications traffic
 between components, it usually makes sense to deploy them on the same plat
form or on platforms that are physically close to one other. This reduces
 communications latency, the delay between the time a message is sent by one
 component and received by another.</p>

 <p> You can document your decisions on hardware and software deployment using UML
 deployment diagrams, which show how software components are distributed across
 hardware platforms.</p>

 <p>If you are developing an embedded system, you may have to take into account
 target characteristics, such as its physical size, power capabilities, the need for real
time responses to sensor events, the physical characteristics of actuators, and its real
time operating system. I discuss embedded systems engineering in Chapter 20.</p>

</html>